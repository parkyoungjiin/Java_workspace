package polymorphism;

public class Ex {

	public static void main(String[] args) {
		/*
		 * 레퍼런스 형변환 
		 * - 어떤 객체(인스턴스)를 다른 타입으로 변환하는 것
		 * - 참조형 데이터타입 간 형변환
		 * - 상속 관계에서만 가능한 변환 (=상속 관계가 아닌 타입끼리 형 변환은 오류)
		 * 
		 * 슈퍼클래스 <-> 서브클래스
		 * - 묵시형 형변환(업캐스팅, Up Catsing, 서브에서 슈퍼)
		 * - 명시적 형변환(다운캐스팅, Down Casting 슈퍼에서 서브)
		 * 
		 * 1. 업캐스팅
		 * - 슈퍼클래스 타입 레퍼런스로 서브클래스 인스턴스를 참조하는 것
		 *   = 서브클래스의 인스턴스를 슈퍼클래스 타입으로 변환하는 것
		 * - 컴파일러에 의해 자동 형변환이 일어난다. (=묵시적 형 변환)
		 *    => 별도의 형변환 연산자를 사용하지 않고도 형변환이 가능하다. (즉, 생략이 가능하다)
		 * - 참조 가능한 영역이 축소됨.
		 *   ex) 슈퍼클래스로부터 상속된 멤버만 접근이 가능해진다.
		 * - 서브클래스 인스턴스 멤버 중 공통 항목을 제외한 나머지에 대한 포기 선언을 하는 것
		 *    => 대신, 하나의 슈퍼클래스 타입으로 여러 서브클래스의 인스턴스를 참조할 수 있다.
		 *   
		 * 작은거 -> 큰거 (명시적 형변환)
		 * 큰거 -> 작은거 (묵시적 형변환)
		 */
	
	Parent p = new Parent();
	// Parent 타입으로 접근 가능한 메서드 1개
	
	p.parentPrn();
	
	System.out.println("==================");
	
	Child c = new Child();
	//Child 타입으로 접근 가능한 메서드 2개
	
	c.childPrn(); // 서브클래스 내의 메서드
	c.parentPrn(); // 상속받은 슈퍼클래스 메서드
	
	System.out.println("================");
	
	int iNum =10;
	long lNum = iNum; // int(작은타입)에서 long(큰타입)으로 형 변환 하기에 자동 형변환 가능
	
	//슈퍼클래스 타입 Parent의 레퍼런스 변수 선언
	
//	Parent p;
	//슈퍼클래스타입 변수 p1에 서브클래스 타입 Child 인스턴스 참조변수를 전달
	p = c; // 묵시적 형변환(업캐스팅)
	// Parent p = new Child();
	// 서브클래스 Child 타입 인스턴스 -> 슈퍼클래스 Parent 타입으로 형 변환이 됐음.
	// => 슈퍼클래스타입 변수가 서브클래스 인스턴스를 참조함(가리킴)
	System.out.println("p와 c의 인스턴스가 동일한가? " + (p==c) );
	
	// Parent 타입 레퍼런스 변수  p로 접근 가능한 메서드 : 1개
	// 참조영역이 줄어든다.
	p.parentPrn(); // 형변환을 통해 참조영역이 줄어들지만, 다형성이 생김.
	// 자신의 메서드(접근 가능), p를 사용하게 되면 childPrn()은 사용할 수 없음.
	// => 서브클래스에서 정의한 메서드는 접근이 불가능하다
	// => 슈퍼클래스 타입으로 업캐스팅 후에 상속된(공통) 메서드만 호출 가능
	// 즉, 슈퍼클래스 타입으로 서브클래스인스턴스를 참조하게 되면 
	// 참조영역에 대한 축소로 인해 서브클래스 메서드가 보이지 않게 된다.
	
	/*
	 * 2. 다운 캐스팅
	 * - 서브클래스의 레퍼런스가 슈퍼클래스의 인스턴스를 참조하는 것
	 *   = 슈퍼클래스의 인스턴스를 서브클래스 타입으로 형변환하는 것
	 * - 참조 가능한 영역이 확대된다.
	 * - 크기는 자식클래스가 더 크니까, 자식이 참조하고 있는 서브클래스를 참조하게 되면 영역이 커진다.
	 * - 자동 형변환이 일어나지 않는다. (= 명시적 형변환이 필요하다.)
	 * - 강제 형변환을 통해 구문 오류가 해결되더라도 실제 실행 시점에서 오류가 발생
	 *   => 존재하지 않은 영역의 참조 위험성 때문
	 *  -------------------------------------------------------------------
	 *  - 다운캐스팅 후에도 실행 시 오류가 발생할 수 있으므로
	 *  인스턴스의 클래스타입과 참조하는 레퍼런스 변수의
	 *  상속관계를 고려해서 다운캐스팅을 수행해야 한다.
	 *  
	 *  => 결론!
	 *     이전에 이미 업캐스팅 된 인스턴스(레퍼런스)
	 *     다시 다운캐스팅 하는 경우에만 안전하다!
	 *     (그 외의 다운캐스팅은 인정되지 않는다.)
	 * 
	 */
	
	
	// 슈퍼클래스 Parent 타입 인스턴스 p2 생성
	Parent p2 = new Parent();
	p2.parentPrn(); //접근 가능한 메서드 1개
	
	//서브클래스 Child 타입 인스턴스 c2 생성
	Child c2 = new Child();
	
//	c2 = p2; // ***오류 발생 !*** 왼쪽 자식, 오른쪽 부모는 오류가 발생한다.
//	=> 슈퍼클래스 타입은 서브클래스 타입으로 자동형변환이 불가능하다!
	// => 반드시 형 변환 연산자를 통해 명시적(강제) 형변환을 해줘야 한다.
	// => ***형변환 문법*** : 자식인스턴스  = (자식클래스명)부모인스턴스;
	c2 = (Child)p2; 
	// 문법적 오류가 해결되더라도 실행시점에서 논리적 오류가 발생한다.
	// 
	
	c2.parentPrn();  
	c2.childPrn();
	// 즉, 존재하지 않은 영역에 대한 참조 위험성 때문에
	// 다운 캐스팅이 불가능하다.
	// 메서드 호출 시점이 아닌, 다운캐스팅 시점에서 오류가 발생한다.
	
	// 기본적으로 다운캐스팅을 자바에서는 허용하지 않는다.
	
	System.out.println("==============");
	
	//다운 캐스팅 가능한 경우
	
	Parent p3 = new Child(); // 자식에서 부모로 가기에 묵시적 형변환 발생
	//업캐스팅에 의해 참조영역이 축소되므로 접근 가능한 메서드 : 1개
	
	p3.parentPrn();
//	p3.childPrn();
	
	//업캐스팅 된 Parent 타입 P3 인스턴스를 child 타입 변수 c3에 전달
	
//	Child c3 = p3; // 컴파일 에러 발생 ! 명시적 형변환 필수!
	Child c3 = (Child)p3;
	
	// 다운캐스팅에 의해 참조영역이 확대대므로 접근 가능한 메서드 2개
	c3.parentPrn();
	c3.childPrn();
	// 다운캐스팅 후에도 아무런 문제없이 인스턴스 사용이 가능하다.
	
	
	
	
	}//Ex 클래스 끝

}


class Parent {
	public void parentPrn() {
		System.out.println("슈퍼클래스의 parentPrn()");
	}
}

class Child extends Parent {
	public void childPrn() {
		System.out.println("서브클래스의 childPrn()");
	}
}
